/*
 * HmOpenAiGpt v 1.0.0.1
 *
 * Copyright (c) 2024 Akitsugu Komiyama
 * under the MIT License
 */


hidemaruversion "9.25.99";

jsmode @"WebView2\HmOpenAiGpt";
js {


// ------------- 会話エンジンの設定項目 -------------

let openai_key = getenv("OPENAI_API_KEY") || getenv("OPENAI_KEY");

// 直接ここでAPIのKEYの文字列を指定しても良いですが、あまり推奨はしません。直書きする場合、このマクロを迂闊に配布して他者にAPIのキーが漏れないよう注意。
// openai_key = "";

if (!openai_key) {
    message("OPENAIのキーが空です");
    throw "OPENAIのキーが空です";
}

const model = "gpt-3.5-turbo"; // "gpt-4o"などの設定可能。しかしながら値段が10倍に跳ね上がるので注意。
                               // "gpt-4-turbo" は、「値段が高いだけで低性能で利用価値なし」なので注意

const max_tokens = 4000;       // この数値は概ね 使用対象のmodelの最大トークンの半分程度を使用するのが望ましい。
                               // 「gpt-3.5-turbo なら 2000」「gpt-4o なら 4000」が目安

const renderpane_custom_param = {
    place: "rightside",        // leftside | rightside | upside | downside
    size: 400,                 // 左や右の配置の時は、横幅のこと。上や下の配置の時は縦幅のこと。
};

const is_one_ai_renderpane = 1;       // AI関連のレンダリング枠は(他の種類のAIも含め)１つだけにする。(複数起動しそうになると、前のものが閉じる）

// --------------------------------------------------

const currentmacrodir = currentmacrodirectory();

// 宣言のみ。この空間マクロで時間を超えて共有するので初期化してはならない。
var avilablePort;

// 有効ポートの受け口。非同期にてここにopenHttpServer関数で代入される。
// 有効なポートが見つからない時や、時間切れになることもありえる
// 一度ポートを探して、0という「見つからない」という値が入っていることもある。この際も一応改めて探す
if (! Boolean(avilablePort) ) {
    openHttpServer();
}

// 簡易Httpサーバーを立てる。ポート自体付きでサーバーを立てることが出来ない限定的なマシンだと失敗するだろう。
function openHttpServer() {
    function getExtractPort(text) {
        const match = text.match(/PORT:(\d+)/);
        return match ? Number(match[1]) : null;
    }

    try {
        // このウィンドウハンドルの値を私ながら簡易サーバーを立ち上げる。
        let currentWindowHandle = hidemaru.getCurrentWindowHandle();

        // このウィンドウハンドルがなくなったら、2秒後に「該当の簡易サーバー」は自動終了する
        // 簡易サーバーがどんどん増えるといったことはなくなる。
        let processInfo = hidemaru.runProcess('"' + currentmacrodir + "\\HmSimpleHttpServer.exe" + '"' + " " + currentWindowHandle, currentmacrodir, "stdioAlive", "sjis");

        // 簡易サーバープログラムの出力を非同期で読み取る。
        // 簡易サーバープログラムはサーバーを起動するとともに、確保したポート番号を標準出力に出す。
        let stdOut = processInfo.stdOut;
        stdOut.onReadLine(readLineAsync);

        // この関数は非同期で呼ばれる
        function readLineAsync(serverOutputText) {
            let port = getExtractPort(serverOutputText);
            if (port == 0) {
                throw "HTTPサーバーのためのポートが確保できませんでした";
            }
            if (port != null) {
                avilablePort = port;
                hidemaru.postExecMacroMemory("js { doMain() }");
            }
        }

    } catch (err) {
        outputAlert(err);
    }
}


const renderPaneTargetName = "HmOpenAiGpt";

// AIウィンドウを１つだけに絞る処理
function oneAIWindowFrameCheck() {
    if (is_one_ai_renderpane) {
        let lastAiRenderPaneTargetName = getstaticvariable( "HmOneAIRenderPane", 2 );
        // 自分だよ、何もしない。
        if (lastAiRenderPaneTargetName == renderPaneTargetName ) {
            return;
        }

        // 他のAIマクロがAIパネル枠を利用しているなら、閉じる
        if (lastAiRenderPaneTargetName) {
            const renderpane_json_param = {
                target: lastAiRenderPaneTargetName,
                show: 0,
            }

            renderpanecommand(renderpane_json_param);
        }
    }
}


let questionTextCache = getQuestionText();

// 質問内容があるかどうか
function hasQuestionText() {
    // getSelectedTextは "" や undefined になりえるので、このような判定
    return Boolean( questionTextCache );
}

// 質問内容のテキスト
function getQuestionText() {
    // ユーザーによって、このような関数が定義されていれば、これを利用する。
    if (typeof(onRequestQuestionText) == "function") {
        return onRequestQuestionText();
    }

    return hidemaru.getSelectedText();
}

// レンダリングペインを再オープンする必要があるかどうか
function noNeedRenderPaneReOpen() {

    // 選択していない時は、ただのコマンドなので、すでに表示済みならリオープンしない
    if (!hasQuestionText()) {
        const renderpane_json_param = {
            target: renderPaneTargetName,
            get: "show",
        };
    
        // 文字列の"0" or "1"なので注意が必要
        let isShowNow = renderpanecommand( renderpane_json_param );
        if (isShowNow == "1" ) {
            return true;
        }
    }

    return false;
}

// レンダリングペインを指定属性＆ポートでオープン
function openRenderPaneCommand(port) {

    if (noNeedRenderPaneReOpen()) { return; }

    let baseUrl = new URL("http://localhost:" + port + "/HmOpenAiGpt.html");

    // このJS内にあるコールバック用にも使う関数をレンダリング枠にクエリーparamとして伝達
    let idHtmlButtonClick = hidemaru.getFunctionId(onHtmlEventHandler);
    let params = new URLSearchParams();
    params.set('idHtmlButtonClick', String(idHtmlButtonClick));

    baseUrl.search = params.toString();
    let targetUrl = baseUrl.href; // オブジェクトから実際のUrl文字列へ

    const renderpane_json_param = {
        target: renderPaneTargetName,
        uri: targetUrl,
        show: 1,
        place: "rightside",
        size: 400,
        initialize: "async",
    };

    // ユーザー指定のもので上書き。
    const renderpane_mix_param = { ...renderpane_json_param, ...renderpane_custom_param };

    renderpanecommand(renderpane_mix_param);

    // １つのウィンドウに絞るフラグがONなら、登録しておく
    if (is_one_ai_renderpane) {
        setstaticvariable( "HmOneAIRenderPane", renderPaneTargetName, 2 );
    }
}



const aiexepath = currentmacrodir + "\\HmOpenAiGpt.exe";

// エラー用途
function outputAlert(msg) {
    let hidemaruexedir = hidemarudir();
    let dll = loaddll(hidemaruexedir + "\\HmOutputPane.dll");
    dll.dllFuncW.Output(msg + "\r\n");
}

// ユーザーの「質問内容」が入るテキストファイル
const questionFileName = currentmacrodir + "\\HmOpenAiGpt.question.txt";
const answerFileName = currentmacrodir + "\\HmOpenAiGpt.txt";

function getTickCount() {
    return tickcount() & 0x7fffffff;
}

// 選択テキストを質問内容としてファイルに保存し、ＡＩを指定のパラメータやモデルで起動
function doSendQuestionContent() {
    let text = getQuestionText();
    let commandline = `"${aiexepath}" "${openai_key}" "${model}" "${max_tokens}"`;
    runex(commandline, 0, 0, "", 0, "", 0, "", 0, "", 2, 1, 0, 0);
//      runex(commandline, 0); // デバッグ用

    let sendcmd = "HmOpenAiGpt.Message(" + getTickCount() + ")\n";
    hidemaru.setTimeout(
        () => { hidemaru.saveTextFile(questionFileName, sendcmd + text, "utf8"); },
        200
    );
}

// ＡＩからの原文をユーザーがマクロから直接要求する場合用。
// ユーザーからは同期に見えるようにするためのクッション
var _completeAnswerText = "";
function syncOnCompleteAnswerText() {
    onCompleteAnswerText(_completeAnswerText);
}

function onHtmlEventHandler(text) {
    if (text == "reset") {
        hidemaru.postExecMacroMemory( "js { resetAI(); }");
    }
    else if (text == "stop") {
        hidemaru.postExecMacroMemory( "js { stopAIAnswer(); }");
    }
    else if (text == "answer_complete") {
        _completeAnswerText = "";
        if (typeof(onCompleteAnswerText) == "function" ) {
            // AIの回答の原文を取得
            _completeAnswerText = hidemaru.loadTextFile(answerFileName) || "";
            // ユーザーが非同期だと理解が大変なので同期にしておく
            hidemaru.postExecMacroMemory( jsmode { "syncOnCompleteAnswerText()" } );
        }
    }
}

function stopAIAnswer() {
    let sendcmd = "HmOpenAiGpt.Cancel(" + getTickCount() + ")\n";
    let text = "応答を停止";
    let commandline = `"${aiexepath}" "HmOpenAiGpt.Cancel()"`;
    runex(commandline, 0, 0, "", 0, "", 0, "", 0, "", 2, 1, 0, 0);
    hidemaru.saveTextFile(questionFileName, sendcmd + text, "utf8");
}

function resetAI() {
    let sendcmd = "HmOpenAiGpt.Clear(" + getTickCount() + ")\n";
    let text = "リセット";
    let commandline = `"${aiexepath}" "HmOpenAiGpt.Clear()"`;
    runex(commandline, 0, 0, "", 0, "", 0, "", 0, "", 2, 1, 0, 0);
    hidemaru.saveTextFile(questionFileName, sendcmd + text, "utf8");
    hidemaru.saveTextFile(answerFileName, "", "utf8");
}

function pasteAIAnswer() {
    let text = hidemaru.loadTextFile(answerFileName);
    insert(text);
}

// テキストを選択せずに、このマクロを実行した時は、
// 「ＡＩの応答を途中キャンセル」あるいは「ＡＩを完全にリセットしてプロセス自体を終了し、会話履歴も消去」することが出来る。
function doSendCommand() {
    let selectMenuID = menu("応答を停止 (&S)", "全リセット (&R)", "応答を張り付け (&V)");
    if (selectMenuID == 1) {
        stopAIAnswer();
    }
    else if (selectMenuID == 2) {
        resetAI();
    }
    else if (selectMenuID == 3) {
        pasteAIAnswer();
    }
}


// HTML/JS用のHttpサーバーを起動。(PHPだと他の環境要らずでたった２個ほどのファイルでシンプルサーバーが動作するので一緒に内包してある)

// 選択範囲の最終座標に移動した方が便利だとわかっている
function gotoSelectEndPosition() {
    // 選択は自動解除した方が便利なようだ
    let cur_selendx = selendx();
    let cur_selendy = selendy();
    escapeselect();
    moveto(cur_selendx, cur_selendy);
}

// メイン処理
function doMain() {
    try {
        // AIウィンドウフレームに絞るかどうか
        oneAIWindowFrameCheck();

        // レインだリングペインをそのポートでlocalhostで開く
        openRenderPaneCommand(avilablePort);

        // 質問があるなら
        if (hasQuestionText()) {
            // それをＡＩへの質問内容として送信
            doSendQuestionContent();
            // 選択を解除し、選択の最後の座標へと移動
            gotoSelectEndPosition();
        } else {
            // それ以外なら、ＡＩにコマンドの送信
            doSendCommand();
        }
    } catch (err) {
        outputAlert(err);
    }
}

if (avilablePort > 0) {
    doMain();
}

} // js

